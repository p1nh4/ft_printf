# Explicação Linha a Linha do Makefile

Vou explicar cada linha detalhadamente:

---

```makefile
NAME        := libftprintf.a
```
**Define o nome do arquivo final** - A biblioteca estática que será criada. O `:=` é atribuição imediata (expande variáveis na hora).

---

```makefile
CC          := cc  
```
**Define o compilador** - `cc` é um link simbólico para o compilador C padrão do sistema (geralmente `gcc` ou `clang`).

---

```makefile
C_FLAGS     := -Wall -Wextra -Werror
```
**Flags de compilação**:
- `-Wall` = ativa todos os warnings comuns
- `-Wextra` = ativa warnings extras
- `-Werror` = trata warnings como erros (código não compila se houver warning)

---

```makefile
AR          := ar
```
**Define o arquivador** - `ar` é o programa que cria bibliotecas estáticas (`.a`).

---

```makefile
AR_FLAGS    := -rcs
```
**Flags do arquivador**:
- `r` = replace (substitui arquivos na biblioteca)
- `c` = create (cria a biblioteca se não existir)
- `s` = index (cria índice para linking mais rápido)

---

```makefile
SRC_DIR     := src 
```
**Diretório dos arquivos fonte** - Onde ficam os arquivos `.c`.

---

```makefile
OBJ_DIR     := obj 
```
**Diretório dos objetos** - Onde serão criados os arquivos `.o` (compilados).

---

```makefile
BIN_DIR     := bin 
```
**Diretório dos binários** - Onde será colocada a biblioteca final `.a`.

---

```makefile
LIBFT       := libft 
```
**Nome do diretório da libft** - Biblioteca auxiliar que será compilada junto.

---

```makefile
INCLUDE_DIR := includes
```
**Diretório dos headers** - Onde ficam os arquivos `.h`.

---

```makefile
SRC         := $(SRC_DIR)/ft_printf.c
```
**Lista de arquivos fonte** - Aqui só tem um: `src/ft_printf.c`. Em projetos maiores, teria mais arquivos.

---

```makefile
INCLUDES    := -I$(INCLUDE_DIR) -I$(LIBFT)
```
**Flags de include** - Diz ao compilador onde procurar arquivos `.h`:
- `-I$(INCLUDE_DIR)` = procura em `includes/`
- `-I$(LIBFT)` = procura em `libft/`

---

```makefile
OBJ         := $(patsubst $(SRC_DIR)/%.c,$(OBJ_DIR)/%.o,$(SRC))
```
**Converte lista de `.c` em lista de `.o`**:
- `patsubst` = "pattern substitute" (substitui padrão)
- Pega `src/ft_printf.c` → transforma em `obj/ft_printf.o`
- Exemplo: se `SRC = src/a.c src/b.c`, então `OBJ = obj/a.o obj/b.o`

---

```makefile
RM := rm -f
```
**Comando para remover arquivos**:
- `rm` = remove
- `-f` = force (não pergunta, não dá erro se arquivo não existe)

---

```makefile
all : $(LIBFT) $(BIN_DIR)/$(NAME)
```
**Target padrão** (executa quando faz só `make`):
- Depende de duas coisas: compilar a `libft` E criar `bin/libftprintf.a`
- O Make garante que as dependências são feitas primeiro

---

```makefile
$(BIN_DIR)/$(NAME) : $(OBJ) $(LIBFT)/libft.a
```
**Regra para criar a biblioteca final** (`bin/libftprintf.a`):
- Depende dos objetos compilados (`obj/ft_printf.o`)
- E da biblioteca libft (`libft/libft.a`)

---

```makefile
    $(AR) $(AR_FLAGS) $@ $^
```
**Comando que cria a biblioteca**:
- `$(AR) $(AR_FLAGS)` = `ar -rcs`
- `$@` = target (o arquivo que estamos criando: `bin/libftprintf.a`)
- `$^` = todas as dependências (`obj/ft_printf.o libft/libft.a`)
- **Resultado**: arquiva os `.o` e a libft numa biblioteca única

⚠️ **IMPORTANTE**: Esta linha DEVE começar com TAB, não espaços!

---

```makefile
$(LIBFT) : 
```
**Regra para compilar a libft**:
- Target é o diretório `libft`

---

```makefile
    $(MAKE) -C $(LIBFT)
```
**Entra no diretório libft e executa make**:
- `$(MAKE)` = chama o make recursivamente
- `-C $(LIBFT)` = muda para o diretório `libft/` antes de executar
- Isso compila a biblioteca libft usando o Makefile dela

---

```makefile
$(OBJ_DIR)/%.o : $(SRC_DIR)/%.c  
```
**Regra de padrão para compilar qualquer `.c` em `.o`**:
- `%.o` = wildcard (qualquer arquivo `.o`)
- `%.c` = arquivo `.c` correspondente
- Exemplo: para criar `obj/ft_printf.o`, procura `src/ft_printf.c`

---

```makefile
    mkdir -p $(OBJ_DIR) $(BIN_DIR)
```
**Cria os diretórios se não existirem**:
- `mkdir -p` = cria diretório (e pais, se necessário), sem erro se já existe
- Cria `obj/` e `bin/` antes de compilar

---

```makefile
    $(CC) $(C_FLAGS) $(INCLUDES)  -c -o $@ $
```
**Compila o arquivo `.c` em `.o`**:
- `$(CC)` = `cc` (compilador)
- `$(C_FLAGS)` = `-Wall -Wextra -Werror`
- `$(INCLUDES)` = `-Iincludes -Ilibft`
- `-c` = compila sem linkar (só cria `.o`)
- `-o $@` = output é o target (`obj/ft_printf.o`)
- `$<` = primeira dependência (`src/ft_printf.c`)

**Comando final expandido**: `cc -Wall -Wextra -Werror -Iincludes -Ilibft -c -o obj/ft_printf.o src/ft_printf.c`

---

```makefile
clean : 
```
**Target para limpar arquivos temporários**.

---

```makefile
    $(RM) $(OBJ)
```
**Remove os objetos compilados** (`obj/ft_printf.o`).

---

```makefile
    $(MAKE) -C $(LIBFT) clean
```
**Chama clean na libft** - Remove os `.o` de lá também.

---

```makefile
fclean : clean
```
**Limpeza completa** - Primeiro executa `clean`, depois continua.

---

```makefile
    $(RM) $(BIN_DIR)/$(NAME) $(OBJ)
```
**Remove a biblioteca final e os objetos**:
- `bin/libftprintf.a`
- `obj/ft_printf.o`

---

```makefile
    $(RM) -rf $(OBJ_DIR) $(BIN_DIR)
```
**Remove os diretórios completamente**:
- `-r` = recursivo (remove diretório e conteúdo)
- `-f` = força (sem perguntar)
- Remove `obj/` e `bin/` inteiros

---

```makefile
    $(MAKE) -C $(LIBFT) fclean
```
**Chama fclean na libft** - Limpeza completa dela também.

---

```makefile
re : fclean all
```
**Rebuild completo**:
1. Executa `fclean` (limpa tudo)
2. Executa `all` (recompila do zero)

---

```makefile
.PHONY: all clean fclean re
```
**Declara targets "phony" (falsos)**:
- Estes não são arquivos reais
- Garante que Make sempre executa estes comandos
- Mesmo se existir um arquivo chamado `clean` ou `all`, o Make ignora e executa o target

---

## Resumo do Fluxo

```
make
  → compila libft (entra em libft/, faz make)
  → cria obj/ e bin/
  → compila src/ft_printf.c → obj/ft_printf.o
  → arquiva obj/ft_printf.o + libft/libft.a → bin/libftprintf.a
```
